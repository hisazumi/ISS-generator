/*
* generated by Xtext
*/
package nel.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import nel.services.McoreGrammarAccess;

import com.google.inject.Inject;

public class McoreParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private McoreGrammarAccess grammarAccess;
		
	public McoreGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_InstructionsAssignment(this, this, 0, inst);
			case 1: return new Instruction_Group(this, this, 1, inst);
			case 2: return new InstType_Group(this, this, 2, inst);
			case 3: return new Coding_Group(this, this, 3, inst);
			case 4: return new Behavior_Group(this, this, 4, inst);
			case 5: return new Expression_Group(this, this, 5, inst);
			case 6: return new LExp_RegAssignment(this, this, 6, inst);
			case 7: return new RExp_Alternatives(this, this, 7, inst);
			case 8: return new Condition_Group(this, this, 8, inst);
			case 9: return new REGSARGS_Alternatives(this, this, 9, inst);
			case 10: return new REGS_Group(this, this, 10, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Model ****************
 *
 * Model:
 *   instructions+=Instruction*;
 *
 **/

// instructions+=Instruction*
protected class Model_InstructionsAssignment extends AssignmentToken  {
	
	public Model_InstructionsAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getInstructionsAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getModelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("instructions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("instructions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getInstructionsInstructionParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_InstructionsAssignment(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule Model ****************/


/************ begin Rule Instruction ****************
 *
 * Instruction:
 *   "instruction" name=ID "{" type=InstType coding=Coding behavior=Behavior "}";
 *
 **/

// "instruction" name=ID "{" type=InstType coding=Coding behavior=Behavior "}"
protected class Instruction_Group extends GroupToken {
	
	public Instruction_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getInstructionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_RightCurlyBracketKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "instruction"
protected class Instruction_InstructionKeyword_0 extends KeywordToken  {
	
	public Instruction_InstructionKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getInstructionAccess().getInstructionKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Instruction_NameAssignment_1 extends AssignmentToken  {
	
	public Instruction_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getInstructionAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_InstructionKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getInstructionAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class Instruction_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public Instruction_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getInstructionAccess().getLeftCurlyBracketKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=InstType
protected class Instruction_TypeAssignment_3 extends AssignmentToken  {
	
	public Instruction_TypeAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getInstructionAccess().getTypeAssignment_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InstType_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInstTypeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInstructionAccess().getTypeInstTypeParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Instruction_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// coding=Coding
protected class Instruction_CodingAssignment_4 extends AssignmentToken  {
	
	public Instruction_CodingAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getInstructionAccess().getCodingAssignment_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Coding_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("coding",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("coding");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCodingRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInstructionAccess().getCodingCodingParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Instruction_TypeAssignment_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// behavior=Behavior
protected class Instruction_BehaviorAssignment_5 extends AssignmentToken  {
	
	public Instruction_BehaviorAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getInstructionAccess().getBehaviorAssignment_5();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Behavior_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("behavior",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("behavior");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBehaviorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInstructionAccess().getBehaviorBehaviorParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Instruction_CodingAssignment_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Instruction_RightCurlyBracketKeyword_6 extends KeywordToken  {
	
	public Instruction_RightCurlyBracketKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getInstructionAccess().getRightCurlyBracketKeyword_6();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_BehaviorAssignment_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Instruction ****************/


/************ begin Rule InstType ****************
 *
 * InstType:
 *   "type" type=InstTypeLabel ";";
 *
 **/

// "type" type=InstTypeLabel ";"
protected class InstType_Group extends GroupToken {
	
	public InstType_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getInstTypeAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InstType_SemicolonKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInstTypeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "type"
protected class InstType_TypeKeyword_0 extends KeywordToken  {
	
	public InstType_TypeKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getInstTypeAccess().getTypeKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// type=InstTypeLabel
protected class InstType_TypeAssignment_1 extends AssignmentToken  {
	
	public InstType_TypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getInstTypeAccess().getTypeAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InstType_TypeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getInstTypeAccess().getTypeInstTypeLabelParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ";"
protected class InstType_SemicolonKeyword_2 extends KeywordToken  {
	
	public InstType_SemicolonKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getInstTypeAccess().getSemicolonKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InstType_TypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule InstType ****************/


/************ begin Rule Coding ****************
 *
 * Coding:
 *   "coding" coding=Binary ";";
 *
 **/

// "coding" coding=Binary ";"
protected class Coding_Group extends GroupToken {
	
	public Coding_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getCodingAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Coding_SemicolonKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCodingRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "coding"
protected class Coding_CodingKeyword_0 extends KeywordToken  {
	
	public Coding_CodingKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getCodingAccess().getCodingKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// coding=Binary
protected class Coding_CodingAssignment_1 extends AssignmentToken  {
	
	public Coding_CodingAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getCodingAccess().getCodingAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Coding_CodingKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("coding",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("coding");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getCodingAccess().getCodingBinaryTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ";"
protected class Coding_SemicolonKeyword_2 extends KeywordToken  {
	
	public Coding_SemicolonKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getCodingAccess().getSemicolonKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Coding_CodingAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Coding ****************/


/************ begin Rule Behavior ****************
 *
 * Behavior:
 *   "behavior" "{" ((expressions+=Expression|conditions+=Condition) ";")* "}";
 *
 **/

// "behavior" "{" ((expressions+=Expression|conditions+=Condition) ";")* "}"
protected class Behavior_Group extends GroupToken {
	
	public Behavior_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBehaviorAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Behavior_RightCurlyBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBehaviorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "behavior"
protected class Behavior_BehaviorKeyword_0 extends KeywordToken  {
	
	public Behavior_BehaviorKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBehaviorAccess().getBehaviorKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "{"
protected class Behavior_LeftCurlyBracketKeyword_1 extends KeywordToken  {
	
	public Behavior_LeftCurlyBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBehaviorAccess().getLeftCurlyBracketKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Behavior_BehaviorKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ((expressions+=Expression|conditions+=Condition) ";")*
protected class Behavior_Group_2 extends GroupToken {
	
	public Behavior_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBehaviorAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Behavior_SemicolonKeyword_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=Expression|conditions+=Condition
protected class Behavior_Alternatives_2_0 extends AlternativesToken {

	public Behavior_Alternatives_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getBehaviorAccess().getAlternatives_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Behavior_ExpressionsAssignment_2_0_0(parent, this, 0, inst);
			case 1: return new Behavior_ConditionsAssignment_2_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=Expression
protected class Behavior_ExpressionsAssignment_2_0_0 extends AssignmentToken  {
	
	public Behavior_ExpressionsAssignment_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBehaviorAccess().getExpressionsAssignment_2_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBehaviorAccess().getExpressionsExpressionParserRuleCall_2_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Behavior_Group_2(parent, next, actIndex, consumed);
			case 1: return new Behavior_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// conditions+=Condition
protected class Behavior_ConditionsAssignment_2_0_1 extends AssignmentToken  {
	
	public Behavior_ConditionsAssignment_2_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBehaviorAccess().getConditionsAssignment_2_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Condition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("conditions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("conditions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConditionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBehaviorAccess().getConditionsConditionParserRuleCall_2_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Behavior_Group_2(parent, next, actIndex, consumed);
			case 1: return new Behavior_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ";"
protected class Behavior_SemicolonKeyword_2_1 extends KeywordToken  {
	
	public Behavior_SemicolonKeyword_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBehaviorAccess().getSemicolonKeyword_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Behavior_Alternatives_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "}"
protected class Behavior_RightCurlyBracketKeyword_3 extends KeywordToken  {
	
	public Behavior_RightCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBehaviorAccess().getRightCurlyBracketKeyword_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Behavior_Group_2(parent, this, 0, inst);
			case 1: return new Behavior_LeftCurlyBracketKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Behavior ****************/


/************ begin Rule Expression ****************
 *
 * Expression:
 *   lexp=LExp "=" rexp=RExp;
 *
 **/

// lexp=LExp "=" rexp=RExp
protected class Expression_Group extends GroupToken {
	
	public Expression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_RexpAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// lexp=LExp
protected class Expression_LexpAssignment_0 extends AssignmentToken  {
	
	public Expression_LexpAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getExpressionAccess().getLexpAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LExp_RegAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("lexp",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("lexp");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLExpRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExpressionAccess().getLexpLExpParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// "="
protected class Expression_EqualsSignKeyword_1 extends KeywordToken  {
	
	public Expression_EqualsSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getExpressionAccess().getEqualsSignKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LexpAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// rexp=RExp
protected class Expression_RexpAssignment_2 extends AssignmentToken  {
	
	public Expression_RexpAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getExpressionAccess().getRexpAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RExp_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rexp",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rexp");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRExpRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExpressionAccess().getRexpRExpParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Expression_EqualsSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Expression ****************/


/************ begin Rule LExp ****************
 *
 * LExp:
 *   reg=REGS;
 *
 **/

// reg=REGS
protected class LExp_RegAssignment extends AssignmentToken  {
	
	public LExp_RegAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLExpAccess().getRegAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLExpRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getREGSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLExpAccess().getRegREGSParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

/************ end Rule LExp ****************/


/************ begin Rule RExp ****************
 *
 * RExp:
 *   arg=REGSARGS|larg=REGSARGS aop=AOPs rarg=REGSARGS;
 *
 **/

// arg=REGSARGS|larg=REGSARGS aop=AOPs rarg=REGSARGS
protected class RExp_Alternatives extends AlternativesToken {

	public RExp_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getRExpAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RExp_ArgAssignment_0(parent, this, 0, inst);
			case 1: return new RExp_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRExpRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// arg=REGSARGS
protected class RExp_ArgAssignment_0 extends AssignmentToken  {
	
	public RExp_ArgAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRExpAccess().getArgAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGSARGS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("arg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("arg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getREGSARGSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRExpAccess().getArgREGSARGSParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// larg=REGSARGS aop=AOPs rarg=REGSARGS
protected class RExp_Group_1 extends GroupToken {
	
	public RExp_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getRExpAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RExp_RargAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// larg=REGSARGS
protected class RExp_LargAssignment_1_0 extends AssignmentToken  {
	
	public RExp_LargAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRExpAccess().getLargAssignment_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGSARGS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("larg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("larg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getREGSARGSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRExpAccess().getLargREGSARGSParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// aop=AOPs
protected class RExp_AopAssignment_1_1 extends AssignmentToken  {
	
	public RExp_AopAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRExpAccess().getAopAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RExp_LargAssignment_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("aop",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("aop");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRExpAccess().getAopAOPsParserRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// rarg=REGSARGS
protected class RExp_RargAssignment_1_2 extends AssignmentToken  {
	
	public RExp_RargAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRExpAccess().getRargAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGSARGS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rarg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rarg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getREGSARGSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRExpAccess().getRargREGSARGSParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RExp_AopAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule RExp ****************/


/************ begin Rule Condition ****************
 *
 * Condition:
 *   "if" "(" larg=REGSARGS cmpop=CMPOPs rarg=REGSARGS "," thentarget=JMPTARGET ","
 *   elsetarget=JMPTARGET ")";
 *
 **/

// "if" "(" larg=REGSARGS cmpop=CMPOPs rarg=REGSARGS "," thentarget=JMPTARGET ","
// elsetarget=JMPTARGET ")"
protected class Condition_Group extends GroupToken {
	
	public Condition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getConditionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Condition_RightParenthesisKeyword_9(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConditionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "if"
protected class Condition_IfKeyword_0 extends KeywordToken  {
	
	public Condition_IfKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getConditionAccess().getIfKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "("
protected class Condition_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public Condition_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getConditionAccess().getLeftParenthesisKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Condition_IfKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// larg=REGSARGS
protected class Condition_LargAssignment_2 extends AssignmentToken  {
	
	public Condition_LargAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionAccess().getLargAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGSARGS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("larg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("larg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getREGSARGSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConditionAccess().getLargREGSARGSParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Condition_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// cmpop=CMPOPs
protected class Condition_CmpopAssignment_3 extends AssignmentToken  {
	
	public Condition_CmpopAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionAccess().getCmpopAssignment_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Condition_LargAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("cmpop",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("cmpop");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getConditionAccess().getCmpopCMPOPsParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// rarg=REGSARGS
protected class Condition_RargAssignment_4 extends AssignmentToken  {
	
	public Condition_RargAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionAccess().getRargAssignment_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGSARGS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rarg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rarg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getREGSARGSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConditionAccess().getRargREGSARGSParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Condition_CmpopAssignment_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ","
protected class Condition_CommaKeyword_5 extends KeywordToken  {
	
	public Condition_CommaKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getConditionAccess().getCommaKeyword_5();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Condition_RargAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// thentarget=JMPTARGET
protected class Condition_ThentargetAssignment_6 extends AssignmentToken  {
	
	public Condition_ThentargetAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionAccess().getThentargetAssignment_6();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Condition_CommaKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("thentarget",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("thentarget");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getConditionAccess().getThentargetJMPTARGETParserRuleCall_6_0();
			return obj;
		}
		return null;
	}

}

// ","
protected class Condition_CommaKeyword_7 extends KeywordToken  {
	
	public Condition_CommaKeyword_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getConditionAccess().getCommaKeyword_7();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Condition_ThentargetAssignment_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// elsetarget=JMPTARGET
protected class Condition_ElsetargetAssignment_8 extends AssignmentToken  {
	
	public Condition_ElsetargetAssignment_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionAccess().getElsetargetAssignment_8();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Condition_CommaKeyword_7(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("elsetarget",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("elsetarget");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getConditionAccess().getElsetargetJMPTARGETParserRuleCall_8_0();
			return obj;
		}
		return null;
	}

}

// ")"
protected class Condition_RightParenthesisKeyword_9 extends KeywordToken  {
	
	public Condition_RightParenthesisKeyword_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getConditionAccess().getRightParenthesisKeyword_9();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Condition_ElsetargetAssignment_8(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Condition ****************/


/************ begin Rule REGSARGS ****************
 *
 * REGSARGS:
 *   reg=REGS|arg=ARGS;
 *
 **/

// reg=REGS|arg=ARGS
protected class REGSARGS_Alternatives extends AlternativesToken {

	public REGSARGS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getREGSARGSAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGSARGS_RegAssignment_0(parent, this, 0, inst);
			case 1: return new REGSARGS_ArgAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getREGSARGSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// reg=REGS
protected class REGSARGS_RegAssignment_0 extends AssignmentToken  {
	
	public REGSARGS_RegAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getREGSARGSAccess().getRegAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getREGSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getREGSARGSAccess().getRegREGSParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// arg=ARGS
protected class REGSARGS_ArgAssignment_1 extends AssignmentToken  {
	
	public REGSARGS_ArgAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getREGSARGSAccess().getArgAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("arg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("arg");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getREGSARGSAccess().getArgARGSParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule REGSARGS ****************/



/************ begin Rule REGS ****************
 *
 * REGS:
 *   "regs" "[" arg=ARGS "]";
 *
 **/

// "regs" "[" arg=ARGS "]"
protected class REGS_Group extends GroupToken {
	
	public REGS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getREGSAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGS_RightSquareBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getREGSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "regs"
protected class REGS_RegsKeyword_0 extends KeywordToken  {
	
	public REGS_RegsKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getREGSAccess().getRegsKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "["
protected class REGS_LeftSquareBracketKeyword_1 extends KeywordToken  {
	
	public REGS_LeftSquareBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getREGSAccess().getLeftSquareBracketKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGS_RegsKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// arg=ARGS
protected class REGS_ArgAssignment_2 extends AssignmentToken  {
	
	public REGS_ArgAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getREGSAccess().getArgAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGS_LeftSquareBracketKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("arg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("arg");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getREGSAccess().getArgARGSParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// "]"
protected class REGS_RightSquareBracketKeyword_3 extends KeywordToken  {
	
	public REGS_RightSquareBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getREGSAccess().getRightSquareBracketKeyword_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new REGS_ArgAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule REGS ****************/





}
